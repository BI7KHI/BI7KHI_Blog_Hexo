---
title: RS485风力变送器代码示例及其在气象直播中的使用
date: 2025-09-24 01:27:38
tags: [传感器,RS485,气象,单片机,轻量web页面,直播应用]
categories: [技术]
cover: /images/RS485风力变送器/image2.png
---
## 捡来的气象站硬件

咸鱼花费200捡了一套基本的气象传感器，想着呢来作为未来中继台可以发挥的一个小职能——作为小型综合气象站使用

200大洋包含的玩意:

* **翻斗式降水量传感器**(全新传感器价格普遍在300左右)
* 一个多因素**百叶箱**(拿来塞温湿度传感器，空气质量传感器之类)
* 风力变送器包含一个**风速传感器**(一个风勺在运输中折断，用热熔胶粘的)，**风向传感器**

所有的传感器均为12V通信，**RS485 Modbus**协议通讯

而后超强台风**桦加沙**即将登陆，想着在直播中加入风速的即时显示故开始了相关折腾

## 单片机方案及其相关硬件

* ESP8266作为连接网络及其相关数据的读取
* TTL to RS485 电平转换模块
* 风速传感器一个
* MT 3608 Boost模块

供电方案采用充电宝供电，临时搭建的仅考虑能用就行

![Draw](/images/RS485风力变送器/draw.png)

## 一坨电路实物

临时搭建的玩意，面包板上的实物如下，然后拿着个垃圾袋挂着:

![电路在垃圾袋里](/images/RS485风力变送器/电路在垃圾袋里.jpg)

## Arduino代码实现,Modbus通信实现代码示例

```cpp
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ModbusMaster.h>
#include <SoftwareSerial.h>

// WiFi配置
const char* ssid = "ChinaNet-ZXBRT4";
const char* password = "#Key298995";

// 创建Web服务器，端口80
ESP8266WebServer server(80);

// 核心参数
#define SENSOR_ADDR 0x01        // 传感器地址
#define WIND_SPEED_REG 0x0000   // 风速寄存器地址
#define BAUDRATE 9600           // 波特率
#define READ_RETRIES 2          // 减少重试次数，避免阻塞
#define READ_TIMEOUT 1000       // 单次读取超时时间(毫秒)

// 软件串口（D5=TX, D6=RX）
SoftwareSerial rs485Serial(12, 14);  // RX=GPIO12(D6), TX=GPIO14(D5)
ModbusMaster node;

// 存储有效风速
float lastValidSpeed = 0.0;
unsigned long lastReadTime = 0;
const unsigned long readInterval = 2000;  // 读取间隔

// 超简单网页HTML内容
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
  <title>实时风速监测</title>
  <style>
    body { font-family: Arial; text-align: center; padding: 20px; }
    .speed { font-size: 4em; font-weight: bold; margin: 30px 0; }
  </style>
</head>
<body>
  <h1>实时风速监测</h1>
  <div class="speed">
    <span id="speedMs">--</span> m/s (<span id="speedKmh">--</span> km/h)
  </div>
  <div>更新时间: <span id="updateTime">--</span></div>

  <script>
    // 简单的AJAX请求函数
    function getData() {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/data', true);
      xhr.timeout = 3000;  // 设置请求超时时间
  
      xhr.onload = function() {
        if (this.status == 200) {
          try {
            var data = JSON.parse(this.responseText);
            document.getElementById('speedMs').textContent = data.s.toFixed(1);
            document.getElementById('speedKmh').textContent = (data.s * 3.6).toFixed(1);
        
            var d = new Date();
            document.getElementById('updateTime').textContent = 
              d.getHours() + ':' + (d.getMinutes()<10?'0':'')+d.getMinutes() + 
              ':' + (d.getSeconds()<10?'0':'')+d.getSeconds();
          } catch(e) {}
        }
      };
  
      xhr.ontimeout = function() {
        // 请求超时不做处理，避免干扰
      };
  
      xhr.send();
    }

    // 初始加载和定时更新
    getData();
    setInterval(getData, 2000);
  </script>
</body>
</html>
)rawliteral";

void setup() {
  // 初始化串口
  Serial.begin(115200);
  
  // 初始化Modbus（简化配置）
  rs485Serial.begin(BAUDRATE, SWSERIAL_8N1);
  node.begin(SENSOR_ADDR, rs485Serial);
  
  // 连接WiFi（带超时控制）
  Serial.print("连接WiFi: ");
  WiFi.begin(ssid, password);
  
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
    delay(500);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi已连接");
    Serial.print("访问: http://");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi连接失败");
  }
  
  // 注册路由（极简处理）
  server.on("/", [](){
    server.send_P(200, "text/html; charset=UTF-8", index_html);
  });
  
  server.on("/data", [](){
    // 快速响应，不阻塞服务器
    String json = "{\"s\":" + String(lastValidSpeed) + "}";
    server.send(200, "application/json", json);
  });
  
  server.begin();
}

void loop() {
  // 优先处理客户端请求，避免阻塞
  server.handleClient();
  
  // 定时读取传感器（不阻塞服务器）
  if (millis() - lastReadTime >= readInterval) {
    lastReadTime = millis();
    readWindSpeed();  // 异步读取，不影响服务器响应
  }
}

// 读取风速（带超时控制，不阻塞主循环）
void readWindSpeed() {
  uint8_t result = node.readHoldingRegisters(WIND_SPEED_REG, 1);
  if (result == node.ku8MBSuccess) {
    uint16_t raw = node.getResponseBuffer(0);
    lastValidSpeed = raw / 2.0;  // 转换系数
    Serial.print("风速: ");
    Serial.println(lastValidSpeed);
  }
}

```

## 直播效果

![效果1](/images/RS485风力变送器/image.png)
![效果2](/images/RS485风力变送器/image2.png)
